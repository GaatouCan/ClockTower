import os
import json
import platform
import re

VERSION = '0.1'

# sql类型
sql_type_map = {
    'BIGINT(20)': "int64",
    'bigint(20)': "int64",
    
    'INT(11)': "int32",
    'int(11)': "int32",

    'TINYINT(4)': "int16",
    'tinyint(4)': "int16",

    'VARCHAR(255)': "string",
    'varchar(255)': "string",

    'TEXT': "string",
    'text': "string",
}

# cpp类型
cpp_type_map = {
    "int64": "int64_t",
    "uint64": "uint64_t",
    "int32": "int32_t",
    "uint32": "uint32_t",
    "int16": "int16_t",
    "uint16": "uint16_t",
    "string": "std::string",
}

def to_upper_camel_case(x):
    """转大驼峰法命名"""
    s = re.sub('_([a-zA-Z])', lambda m: (m.group(1).upper()), x)
    return s[0].upper() + s[1:]

def parse_table_field(line: str) -> dict:
    """解析单行table字段"""
    if line.endswith(','):
        line = line[:-1]

    field_info = {}
    temp = line.split(' ')

    # 类型解析
    field_info["name"] = temp[0][1:-1]
    field_info["type"] = sql_type_map[temp[1].strip()]

    if temp[2] and (temp[2] == "UNSIGNED" or temp[2] == "unsigned"):
        field_info["type"] = 'u' + field_info["type"]

    for idx, str in enumerate(temp):
        # 默认值
        if str.startswith('DEFAULT'):
            field_info['default'] = temp[idx + 1]

        # 注释
        if str.startswith('COMMENT'):
            field_info['comment'] = temp[idx + 1][1:-1]

    return field_info


def generate_orm_clazz(src: str, dist: str):
    """生成ORM CPP类"""

    assert src, 'sql输入路径错误'
    assert dist, 'orm输出路径错误'

    print('sql 输入路径: ' + os.getcwd() + '\\' + src)
    print('orm 输出路径: ' + os.getcwd() + '\\' + dist)

    if not os.path.exists(dist):
        os.makedirs(dist)
        print("创建ORM文件夹")

    sql_list = {}

    for root, dirs, files in os.walk(src):
        for file in files:
            if not file.endswith('.sql'):
                continue

            table_info = {}
            table_info['field'] = {}
            next = False

            with open(os.path.join(root, file), 'r', encoding='utf-8') as file:
                # sql文件名（无.sql后缀）
                file_name = os.path.basename(file.name)
                file_name, file_extension = os.path.splitext(file_name)
                sql_list[file_name] = []
            
                line = file.readline()
                while line:
                    line = line.strip()

                    # 表名
                    if line.startswith("CREATE TABLE"):
                        if next:
                            sql_list[file_name].append(table_info)
                            table_info = {}
                            table_info['field'] = {}
                        
                        next = True
                    
                        temp = line.split(' ')
                        table_info['name'] = temp[2][1:-1]

                    # 字段
                    if line.startswith('`'):
                        field_info = parse_table_field(line)
                        table_info['field'][field_info['name']] = field_info

                    # 键
                    if line.startswith("PRIMARY KEY"):
                        position = line.index('(')
                        line = line[position + 1:-1]

                        temp = line.split(',')

                        for key in temp:
                            table_info['field'][key.strip()[1:-1]]['key'] = True

                    # 表定义结束
                    if line.startswith(')'):
                        line = line[1:]
                        if line.endswith(';'):
                            line = line[:-1]

                        temp = line.split(' ')
                        for idx, str in enumerate(temp):
                            if str == 'COMMENT':
                                table_info['comment'] = temp[idx+1][1:-1]

                    line = file.readline()   

                if next:
                    sql_list[file_name].append(table_info)

                print("\t已加载 %s" % file.name)    

    # 生成JSON数据文件
    with open(os.path.join(dist[:-4], 'struct.json'), 'w', encoding='utf-8') as file:
        file.write(json.dumps(sql_list, indent=4, ensure_ascii=False))

    
    file_count = 0
    for file_name, table_list in sql_list.items():
    
        # 定义头文件
        with open(os.path.join(dist, file_name + '.orm.h'), 'w', encoding='utf-8') as file:

            file.write('''/**
 * Object Relational Mapping CPP Class Define
 * This file is generated by Python script. Do not edit!!!
 * Python version: v%s
 * Script version: v%s
 * Source file: /sql/%s
 */\n\n''' % (platform.python_version(), VERSION, file_name))

            file.write('#pragma once\n\n')
            file.write('#include "../../src/system/database/IDBTable.h"\n\n')

            file.write('namespace orm {\n\n')

            for table in table_list:
                # 类定义开始
                file.write('\tclass DBTable_%s final : public IDBTable {\n' % to_upper_camel_case(table['name']))
                file.write('\tpublic:\n')

                construct_str = '\t\t\t'

                for field in table['field'].values():
                    # 表字段映射为类成员变量
                    file.write("\t\t%s %s" % (cpp_type_map[field['type']], field['name']))
            
                    if field['type'] != "string":
                        if 'default' in field.keys():
                            file.write(' = %s' % field['default'])
                        else:
                            file.write(' = 0')

                    file.write(";\n")

                    # 含参构造函数参数列表
                    if 'int' in cpp_type_map[field['type']]:
                        construct_str = construct_str + cpp_type_map[field['type']] + ' ' + field['name'] + ", \n\t\t\t"
                    else:
                        construct_str = construct_str + cpp_type_map[field['type']] + ' ' + field['name'] + ", "

                if len(construct_str) > 6:
                    construct_str = construct_str[:-6]

                file.write('\n\t\tDBTable_%s() = default;\n\n' % to_upper_camel_case(table['name']))

                # 含参构造函数
                file.write('\t\tDBTable_%s(\n%s\n\t\t);\n\n' % (to_upper_camel_case(table['name']), construct_str))

                # 纯虚函数重写
                file.write('\t\t[[nodiscard]] constexpr const char* GetTableName() const override {\n')
                file.write('\t\t\treturn "%s";\n' % table['name'])
                file.write('\t\t}\n\n')
            
                file.write('\t\tmysqlx::RowResult Query(mysqlx::Table &table) override;\n')
                file.write('\t\tmysqlx::RowResult Query(mysqlx::Schema &schema) override;\n\n')
                file.write('\t\tvoid Read(mysqlx::Row &row) override;\n\n')
                file.write('\t\tvoid Write(mysqlx::Table &table) override;\n')
                file.write('\t\tvoid Write(mysqlx::Schema &schema) override;\n\n')
                file.write('\t\tvoid Remove(mysqlx::Table &table) override;\n')
                file.write('\t\tvoid Remove(mysqlx::Schema &schema) override;\n\n')

                file.write('\t}; // DBTable_%s\n\n' % to_upper_camel_case(table['name']))
        
            file.write('} // orm')

        # cpp 文件定义
        with open(os.path.join(dist, file_name + '.orm.cpp'), 'w', encoding='utf-8') as file:

            file.write('''/**
 * Object Relational Mapping CPP Class Implement
 * This file is generated by Python script. Do not edit!!!
 * Python version: v%s
 * Script version: v%s
 */\n\n''' % (platform.python_version(), VERSION))
        
            file.write('#include "%s.orm.h"\n\n' % file_name)

            file.write('namespace orm {\n\n')

            for table in table_list:

                # 含参构造函数参数列表
                construct_str = ''
            
                # 含参构造函数成员变量初始化
                init_str = ''

                # 条件字符串
                where_str = ''
                bind_expr = ''

                # 条件表达式
                where_expr = ''

                insert_field_str = ''
                insert_value_str = ''

                # 根据字段拼接所需字符串
                for field in table['field'].values():

                    if 'int' in cpp_type_map[field['type']]:
                        construct_str = construct_str + 'const ' + cpp_type_map[field['type']] + ' ' + field['name'] + ", "
                    else:
                        construct_str = construct_str + 'const ' + cpp_type_map[field['type']] + ' ' + field['name'] + ", "
                
                    init_str = init_str + field['name'] + '(' + field['name'] + "), \n\t\t  "
                    insert_field_str = insert_field_str + '\"' + field['name'] + '\", '
                    insert_value_str = insert_value_str + field['name'] + ', '

                    if "key" in field and field["key"]:
                        where_str = where_str + field["name"] + ' = :' + field["name"] + ' AND '
                        bind_expr = bind_expr + '.bind(\"' + field["name"] + '\", ' + field["name"] + ')'   

                # 字符串去尾
                if len(construct_str) > 2:
                    construct_str = construct_str[:-2]

                if len(init_str) > 2:
                    init_str = init_str[:-7]

                if len(where_str) > 5:
                    where_str = where_str[:-5]

                if len(insert_field_str) > 2:
                    insert_field_str = insert_field_str[:-2]

                if len(insert_value_str) > 2:
                    insert_value_str = insert_value_str[:-2]

                where_expr = '.where(\"' + where_str + '\")' + bind_expr
            
                file.write('\t//===================================== table: %s =====================================\n\n' % table['name'])
            
                # 含参构造函数
                file.write('\tDBTable_%s::DBTable_%s(%s)\n\t\t: %s {\n\t}\n\n' % (to_upper_camel_case(table['name']), to_upper_camel_case(table['name']), construct_str, init_str))

                # file.write('\tstd::string DBTable_%s::GetTableName() {\n' % to_upper_camel_case(table['name']))
                # file.write('\t\treturn "%s";\n\t}\n\n' % table['name'])

                # 查找函数实现
                file.write('\tmysqlx::RowResult DBTable_%s::Query(mysqlx::Table &table) {\n' % to_upper_camel_case(table['name']))
                file.write('\t\treturn table.select()\n')
                file.write('\t\t\t%s\n' % where_expr)
                file.write('\t\t\t.execute();\n')
                file.write('\t}\n\n')
            
                # Query(mysqlx::Schema &schema)
                file.write('\tmysqlx::RowResult DBTable_%s::Query(mysqlx::Schema &schema) {\n' % to_upper_camel_case(table['name']))
            
                file.write('\t\tmysqlx::Table table = schema.getTable(GetTableName());\n')
                file.write('\t\tif (!table.existsInDatabase())\n')
                file.write('\t\t\treturn {};\n\n')

                file.write('\t\treturn Query(table);\n')
                file.write('\t}\n\n')

                # 读取函数
                file.write('\tvoid DBTable_%s::Read(mysqlx::Row &row) {\n' % to_upper_camel_case(table['name']))
                file.write('\t\tif (row.isNull())\n \t\t\treturn;\n\n')

                count = 0
                for field in table['field'].values():
                    type = cpp_type_map[field['type']]
                    if type == "int16_t":
                        type = "int32_t"
                        file.write('\t\t%s = static_cast<int16_t>(row[%d].get<%s>());\n' % (field['name'], count, type))
                    elif type == "uint16_t":
                        type = "uint32_t"
                        file.write('\t\t%s = static_cast<uint16_t>(row[%d].get<%s>());\n' % (field['name'], count, type))
                    else:
                        file.write('\t\t%s = row[%d].get<%s>();\n' % (field['name'], count, type))
                    count += 1

                file.write('\t}\n\n')

                # 写函数
                file.write('\tvoid DBTable_%s::Write(mysqlx::Table &table) {\n' % to_upper_camel_case(table['name']))
                file.write('\t\tmysqlx::RowResult result = Query(table);\n\n')

                # 如果已存在相同键 则调用update()
                file.write("\t\tif (const mysqlx::Row row = result.fetchOne(); !row.isNull()) {\n")

                file.write("\t\t\ttable.update()\n")
                for field in table['field'].values():
                    if "key" not in field or not field["key"]:
                        file.write('\t\t\t\t.set(\"%s\", %s)\n' % (field["name"], field["name"]))
            
                file.write('\t\t\t\t%s\n' % where_expr)
                file.write('\t\t\t\t.execute();\n') 

                # 否则调用insert()
                file.write("\t\t} else {\n")
                file.write("\t\t\ttable.insert(%s)\n" % insert_field_str)
                file.write("\t\t\t\t.values(%s)\n" % insert_value_str)
                file.write('\t\t\t\t.execute();\n') 

                file.write("\t\t}\n")
                file.write('\t}\n\n')

                # 写函数重载
                file.write('\tvoid DBTable_%s::Write(mysqlx::Schema &schema) {\n' % to_upper_camel_case(table['name']))
                file.write('\t\tmysqlx::Table table = schema.getTable(GetTableName());\n')
                file.write('\t\tif (!table.existsInDatabase())\n')
                file.write('\t\t\treturn;\n\n')

                file.write('\t\tWrite(table);\n')
                file.write('\t}\n\n')

                # 删除函数实验
                file.write('\tvoid DBTable_%s::Remove(mysqlx::Table &table) {\n' % to_upper_camel_case(table['name']))
                file.write('\t\ttable.remove()\n')
                file.write('\t\t\t%s\n' % where_expr)
                file.write('\t\t\t.execute();\n')

                file.write('\t}\n\n')

                # 删除函数重载
                file.write('\tvoid DBTable_%s::Remove(mysqlx::Schema &schema) {\n' % to_upper_camel_case(table['name']))

                file.write('\t\tmysqlx::Table table = schema.getTable(GetTableName());\n')
                file.write('\t\tif (!table.existsInDatabase())\n')
                file.write('\t\t\treturn;\n\n')

                file.write('\t\tRemove(table);\n')

                file.write('\t}\n\n')

                print("\t已生成类 DBTable_%s" % to_upper_camel_case(table['name']))
        
            file.write('} // orm')
        file_count += 1

    print('已完成%d个文件转换' % file_count)
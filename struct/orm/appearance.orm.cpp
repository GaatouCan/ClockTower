/**
 * Object Relational Mapping CPP Class Implement
 * This file is generated by Python script. Do not edit!!!
 * Generated time: 2024-10-18 19:58:20
 * Python version: v3.12.7
 * Script version: v0.1
 */

#include "appearance.orm.h"

namespace orm {

	//===================================== table: appearance =====================================

	DBTable_Appearance::DBTable_Appearance(const uint64_t pid, const uint32_t avatar, const uint32_t avatar_frame)
		: pid(pid), 
		  avatar(avatar), 
		  avatar_frame(avatar_frame) {
	}

	mysqlx::RowResult DBTable_Appearance::Query(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("appearance");
		if (!table.existsInDatabase())
			return {};

		mysqlx::RowResult result = table.select()
			.where("pid = :pid").bind("pid", pid)
			.execute();

		return result;
	}

	void DBTable_Appearance::Read(mysqlx::Row &row) {
		if (row.isNull())
 			return;

		pid = row[0].get<uint64_t>();
		avatar = row[1].get<uint32_t>();
		avatar_frame = row[2].get<uint32_t>();
	}

	void DBTable_Appearance::Write(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("appearance");
		if (!table.existsInDatabase())
			return;

		mysqlx::RowResult result = Query(schema);

		if (const mysqlx::Row row = result.fetchOne(); !row.isNull()) {
			table.update()
				.set("avatar", avatar)
				.set("avatar_frame", avatar_frame)
				.where("pid = :pid").bind("pid", pid)
				.execute();
		} else {
			table.insert("pid", "avatar", "avatar_frame")
				.values(pid, avatar, avatar_frame)
				.execute();
		}
	}

	void DBTable_Appearance::Remove(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("appearance");
		if (!table.existsInDatabase())
			return;

		table.remove()
			.where("pid = :pid").bind("pid", pid)
			.execute();
	}

	//===================================== table: avatar =====================================

	DBTable_Avatar::DBTable_Avatar(const uint64_t pid, const uint32_t index, const uint64_t expired_time, const int16_t activated, const int16_t in_used)
		: pid(pid), 
		  index(index), 
		  expired_time(expired_time), 
		  activated(activated), 
		  in_used(in_used) {
	}

	mysqlx::RowResult DBTable_Avatar::Query(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar");
		if (!table.existsInDatabase())
			return {};

		mysqlx::RowResult result = table.select()
			.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
			.execute();

		return result;
	}

	void DBTable_Avatar::Read(mysqlx::Row &row) {
		if (row.isNull())
 			return;

		pid = row[0].get<uint64_t>();
		index = row[1].get<uint32_t>();
		expired_time = row[2].get<uint64_t>();
		activated = static_cast<int16_t>(row[3].get<int32_t>());
		in_used = static_cast<int16_t>(row[4].get<int32_t>());
	}

	void DBTable_Avatar::Write(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar");
		if (!table.existsInDatabase())
			return;

		mysqlx::RowResult result = Query(schema);

		if (const mysqlx::Row row = result.fetchOne(); !row.isNull()) {
			table.update()
				.set("expired_time", expired_time)
				.set("activated", activated)
				.set("in_used", in_used)
				.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
				.execute();
		} else {
			table.insert("pid", "index", "expired_time", "activated", "in_used")
				.values(pid, index, expired_time, activated, in_used)
				.execute();
		}
	}

	void DBTable_Avatar::Remove(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar");
		if (!table.existsInDatabase())
			return;

		table.remove()
			.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
			.execute();
	}

	//===================================== table: avatar_frame =====================================

	DBTable_AvatarFrame::DBTable_AvatarFrame(const uint64_t pid, const uint32_t index, const uint64_t expired_time, const int16_t activated, const int16_t in_used)
		: pid(pid), 
		  index(index), 
		  expired_time(expired_time), 
		  activated(activated), 
		  in_used(in_used) {
	}

	mysqlx::RowResult DBTable_AvatarFrame::Query(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar_frame");
		if (!table.existsInDatabase())
			return {};

		mysqlx::RowResult result = table.select()
			.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
			.execute();

		return result;
	}

	void DBTable_AvatarFrame::Read(mysqlx::Row &row) {
		if (row.isNull())
 			return;

		pid = row[0].get<uint64_t>();
		index = row[1].get<uint32_t>();
		expired_time = row[2].get<uint64_t>();
		activated = static_cast<int16_t>(row[3].get<int32_t>());
		in_used = static_cast<int16_t>(row[4].get<int32_t>());
	}

	void DBTable_AvatarFrame::Write(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar_frame");
		if (!table.existsInDatabase())
			return;

		mysqlx::RowResult result = Query(schema);

		if (const mysqlx::Row row = result.fetchOne(); !row.isNull()) {
			table.update()
				.set("expired_time", expired_time)
				.set("activated", activated)
				.set("in_used", in_used)
				.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
				.execute();
		} else {
			table.insert("pid", "index", "expired_time", "activated", "in_used")
				.values(pid, index, expired_time, activated, in_used)
				.execute();
		}
	}

	void DBTable_AvatarFrame::Remove(mysqlx::Schema &schema) {
		mysqlx::Table table = schema.getTable("avatar_frame");
		if (!table.existsInDatabase())
			return;

		table.remove()
			.where("pid = :pid AND index = :index").bind("pid", pid).bind("index", index)
			.execute();
	}

} // orm
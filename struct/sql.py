import os
import json
import datetime
import re

PROJECT_NAME = 'demo'

TARGET_DIR = 'sql'
GENERATED_DIR = 'orm'

if not os.path.exists(GENERATED_DIR):
    os.makedirs(GENERATED_DIR)
    print(f"Create Directory {GENERATED_DIR}")

date_str = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
VERSION = '0.1'

table_list = {}

sql_type_map = {
    'BIGINT(20)': "int64",
    'bigint(20)': "int64",
    
    'INT(11)': "int32",
    'int(11)': "int32",

    'TINYINT(4)': "int16",
    'tinyint(4)': "int16",

    'VARCHAR(255)': "string",
    'varchar(255)': "string",

    'TEXT': "string",
    'text': "string",
}

code_type_map = {
    "int64": "int64_t",
    "uint64": "uint64_t",
    "int32": "int32_t",
    "uint32": "uint32_t",
    "int16": "int16_t",
    "uint16": "uint16_t",
    "string": "std::string",
}

def to_upper_camel_case(x):
    """转大驼峰法命名"""
    s = re.sub('_([a-zA-Z])', lambda m: (m.group(1).upper()), x)
    return s[0].upper() + s[1:]

def parse_field(line: str) -> dict:
    if line.endswith(','):
        line = line[:-1]

    field_info = {}
    temp = line.split(' ')

    field_info["name"] = temp[0][1:-1]
    field_info["type"] = sql_type_map[temp[1].strip()]

    if temp[2] and (temp[2] == "UNSIGNED" or temp[2] == "unsigned"):
        field_info["type"] = 'u' + field_info["type"]

    for idx, str in enumerate(temp):
        if str.startswith('DEFAULT'):
            field_info['default'] = temp[idx + 1]

        if str.startswith('COMMENT'):
            field_info['comment'] = temp[idx + 1][1:-1]

    return field_info


for root, dirs, files in os.walk(TARGET_DIR):
    for file in files:
        if not file.endswith('.sql'):
            continue

        table_info = {}
        table_info['field'] = {}
        next = False

        with open(os.path.join(root, file), 'r', encoding='utf-8') as file:
            file_name = os.path.basename(file.name)
            file_name, file_extension = os.path.splitext(file_name)
            table_list[file_name] = []
            line = file.readline()
            while line:
                line = line.strip()

                if line.startswith("CREATE TABLE"):
                    if next:
                        table_list[file_name].append(table_info)
                        table_info = {}
                        table_info['field'] = {}
                        
                    next = True
                    
                    temp = line.split(' ')
                    table_info['name'] = temp[2][1:-1]

                if line.startswith('`'):
                    field_info = parse_field(line)
                    table_info['field'][field_info['name']] = field_info

                if line.startswith("PRIMARY KEY"):
                    position = line.index('(')
                    line = line[position + 1:-1]

                    temp = line.split(',')

                    for key in temp:
                        table_info['field'][key.strip()[1:-1]]['key'] = True

                if line.startswith(')'):
                    line = line[1:]
                    if line.endswith(';'):
                        line = line[:-1]

                    temp = line.split(' ')
                    for idx, str in enumerate(temp):
                        if str == 'COMMENT':
                            table_info['comment'] = temp[idx+1][1:-1]

                line = file.readline()   

            if next:
                table_list[file_name].append(table_info)       

with open(os.path.join(GENERATED_DIR[:-4], 'struct.json'), 'w', encoding='utf-8') as file:
    file.write(json.dumps(table_list, indent=4, ensure_ascii=False))
                  

for file_name, table_list in table_list.items():
    with open(os.path.join(GENERATED_DIR, file_name + '.orm.h'), 'w', encoding='utf-8') as file:

        file.write('/**\n * This file is generated by script. Do not edit!\n')
        file.write(' * Generated at: %s\n' % date_str)
        file.write(' */\n\n')

        file.write('#pragma once\n\n')
        file.write('#include "../../src/base/system/database/DBTable.h"\n\n')
        file.write('#include <format>\n\n')

        file.write('namespace orm {\n\n')

        for table in table_list:

            file.write('\tclass UDBTable_%s final : public base::IDBTable {\n' % to_upper_camel_case(table['name']))
            file.write('\tpublic:\n')

            construct_str_1 = ''
            construct_str_2 = ''

            select_str = ''

            replace_str_1 = ''
            replace_str_2 = ''

            for field in table['field'].values():
                file.write("\t\t%s %s" % (code_type_map[field['type']], field['name']))
            
                if field['type'] != "string":
                    if 'default' in field.keys():
                        file.write(' = %s' % field['default'])
                    else:
                        file.write(' = 0')

                file.write(";\n")

                if 'int' in code_type_map[field['type']]:
                    construct_str_1 = construct_str_1 + 'const ' + code_type_map[field['type']] + ' ' + field['name'] + ", "
                else:
                    construct_str_1 = construct_str_1 + 'const ' + code_type_map[field['type']] + ' ' + field['name'] + ", "
                construct_str_2 = construct_str_2 + field['name'] + '(' + field['name'] + "), \n\t\t\t  "

                if "key" in field and field["key"]:
                    select_str = select_str + field["name"] + ' = :' + field["name"] + ' AND '

                replace_str_1 = replace_str_1 + field['name'] + ", "
                replace_str_2 = replace_str_2 + "{}, "

            if len(construct_str_1) > 2:
                construct_str_1 = construct_str_1[:-2]

            if len(construct_str_2) > 2:
                construct_str_2 = construct_str_2[:-8]

            if len(select_str) > 5:
                select_str = select_str[:-5]

            if len(replace_str_1) > 2:
                replace_str_1 = replace_str_1[:-2]

            if len(replace_str_2) > 2:
                replace_str_2 = replace_str_2[:-2]    


            file.write('\n\t\tUDBTable_%s() = default;\n\n' % to_upper_camel_case(table['name']))
            file.write('\t\tUDBTable_%s(%s)\n\t\t\t: %s {} \n\n' % (to_upper_camel_case(table['name']), construct_str_1, construct_str_2))
            file.write('\t\t~UDBTable_%s() override = default;\n\n' % to_upper_camel_case(table['name']))

            # Query
            file.write('\t\tvoid Query(mysqlx::Schema &schema) override {\n')
            
            file.write('\t\t\tmysqlx::Table table = schema.getTable("%s");\n' % table['name'])
            file.write('\t\t\tif (!table.existsInDatabase())\n')
            file.write('\t\t\t\treturn;\n\n')

            file.write('\t\t\tmysqlx::RowResult result = table\n')
            file.write('\t\t\t\t.select()\n')

            file.write('\t\t\t\t.where(\"%s\")\n' % select_str)
            for field in table['field'].values():
                if "key" in field and field["key"]:
                    file.write('\t\t\t\t.bind(\"%s\", %s)\n' % (field["name"], field["name"]))

            file.write('\t\t\t\t.execute();\n\n')        

            file.write("\t\t\tif (mysqlx::Row row = result.fetchOne(); !row.isNull()) {\n")
            file.write("\t\t\t\tRead(row);\n")
            file.write("\t\t\t}\n")
           
            file.write('\t\t}\n\n')

            # Read
            file.write('\t\tvoid Read(mysqlx::Row &row) override {\n')
            file.write('\t\t\tif (row.isNull())\n \t\t\t\treturn;\n\n')

            count = 0
            for field in table['field'].values():
                type = code_type_map[field['type']]
                if type == "int16_t":
                    type = "int32_t"
                    file.write('\t\t\t%s = static_cast<int16_t>(row[%d].get<%s>());\n' % (field['name'], count, type))
                elif type == "uint16_t":
                    type = "uint32_t"
                    file.write('\t\t\t%s = static_cast<uint16_t>(row[%d].get<%s>());\n' % (field['name'], count, type))
                else:
                    file.write('\t\t\t%s = row[%d].get<%s>();\n' % (field['name'], count, type))
                count += 1

            file.write('\t\t}\n\n')

            # Write
            file.write('\t\tvoid Write(mysqlx::Session &session) override {\n')
            file.write('\t\t\tconst auto str = std::format("REPLACE INTO %s (%s) VALUES (%s)", %s);\n' % (table['name'], replace_str_1, replace_str_2, replace_str_1))
            file.write('\t\t\tsession.sql(str).execute();\n')
            file.write('\t\t}\n\n')

            # Delete
            file.write('\t\tvoid Remove(mysqlx::Schema &schema) override {\n')

            file.write('\t\t\tmysqlx::Table table = schema.getTable("%s");\n' % table['name'])
            file.write('\t\t\tif (!table.existsInDatabase())\n')
            file.write('\t\t\t\treturn;\n\n')

            file.write('\t\t\ttable.remove()\n')
            file.write('\t\t\t\t.where(\"%s\")\n' % select_str)
            for field in table['field'].values():
                if "key" in field and field["key"]:
                    file.write('\t\t\t\t.bind(\"%s\", %s)\n' % (field["name"], field["name"]))

            file.write('\t\t\t\t.execute();\n\n')

            file.write('\t\t}\n')

            file.write('\t};\n\n')
        
        file.write('} // orm')